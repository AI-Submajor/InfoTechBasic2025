<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>相互評価フォーム（ラジオ版 / クラス切替対応）</title>
  <!-- build-id はキャッシュ確認用（このHTML自体の版を識別） -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Hiragino Sans", "Noto Sans JP", sans-serif; margin: 24px; line-height: 1.6; }
    h1 { margin-bottom: 4px; }
    .section { border: 1px solid #ddd; border-radius: 10px; padding: 16px; margin: 16px 0; background: #fafafa; }
    .team-title { font-weight: 700; font-size: 1.1rem; }
    .criteria { display: grid; grid-template-columns: 1fr; gap: 8px; }
    .criterion { border: 1px solid #eee; border-radius: 8px; padding: 10px; background: #fff; }
    .choices { display: grid; grid-template-columns: 1fr; gap: 6px; margin-top: 6px; }
    label.choice { display: inline-flex; align-items: center; gap: 8px; }
    textarea { width: 100%; min-height: 70px; resize: vertical; }
    input[type="text"], select { width: 100%; padding: 8px; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .save { margin-top: 20px; }
    button { padding: 10px 16px; font-size: 1rem; border: none; border-radius: 8px; background: #0d6efd; color: #fff; cursor: pointer; }
    button:hover { opacity: 0.95; }
    .hint { color: #555; font-size: 0.9rem; }
    .err { outline: 2px solid #e63946; background: #fff3f3; }
    .muted { color: #666; font-size: 0.9rem; }
    #errorBox { display:none; border:1px solid #e63946; background:#fff3f3; color:#5b0008; padding:12px; border-radius:8px; margin-top:12px; }
    #errorBox ul { margin:8px 0 0 20px; }
    #loadStatus { margin: 8px 0; color:#444; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#f2f2f2; border:1px solid #ddd; border-radius:4px; padding:2px 6px; }
  </style>
</head>
<body>
  <h1 id="pageTitle">相互評価フォーム</h1>

  <div id="loadStatus" class="muted">データを読み込み中…</div>
  <div class="muted">クラス切替：URL に <span class="kbd">?match=class-a</span> のように指定（既定：<span class="kbd">class-all</span>）。</div>

  <div class="section">
    <label>自分の名前（CSVファイル名に使われます）<br />
      <input type="text" id="myName" placeholder="氏名を入力" />
    </label>
  </div>

  <div class="section">
    <label>自分のチームを選択してください（自チームは評価対象から自動で除外されます）<br />
      <select id="myTeam">
        <option value="">（読み込み中）</option>
      </select>
    </label>
    <div class="muted">※ 自分のチームは非表示になり、CSVにも含まれません。</div>
  </div>

  <div id="teamsContainer"></div>

  <div class="save">
    <button id="saveBtn">CSVで保存</button>
    <div class="hint">CSV（ヘッダ付き）：タイムスタンプ, 自分の名前, 評価対象チーム, 観点1, 観点2, 観点3, 観点4, 良かった点, 改善できる点</div>
    <div id="saveDialogStatus" class="muted"></div>
    <div id="errorBox" role="alert" aria-live="polite"></div>
  </div>

  <script>
    // ================= 共通設定 =================
    // このHTMLファイルの版（キャッシュ確認用）
    // ※新しい版をアップロードしたら、この値も更新してください。
    const BUILD_ID = "2026-01-18T00:00:00+09:00";

// 観点は外部設定ファイルから読み込みます（1行=1観点テキスト）
// 例: ./setting/eval-points.txt
let CRITERIA = [];

const DEFAULT_CRITERIA = [
  "ペルソナからの要件整理で現実感がありましたか?",
  "ブランドの絞り込みなどでデータ分析はしっかりしていましたか?",
  "商品の選択結果と根拠の繋がりの納得感はありましたか? (論理思考)",
  "POPでの訴求は魅力的と感じましたか?"
];

    const SCALE = [
      { value: 1, text: "1: 全くそう思わない" },
      { value: 2, text: "2: あまりそう思わない" },
      { value: 3, text: "3: どちらかというとそう思う" },
      { value: 4, text: "4: 非常にそう思う" }
    ];

    let HEADER = []; // CRITERIA 読み込み後に動的生成
function buildHeader(){
  const critCols = CRITERIA.map((_, i) => `観点${i+1}`);
  HEADER = ["タイムスタンプ","自分の名前","評価対象チーム", ...critCols, "良かった点","改善できる点"];
}
    const EOL = "\r\n"; // Windows/Excel 互換の改行

    function formatTimestamp(){
      const d = new Date();
      const pad = n => String(n).padStart(2,'0');
      const y = d.getFullYear();
      const m = pad(d.getMonth()+1);
      const day = pad(d.getDate());
      const h = pad(d.getHours());
      const mi = pad(d.getMinutes());
      const s = pad(d.getSeconds());
      return `${y}-${m}-${day} ${h}:${mi}:${s}`; // ローカル時刻
    }

    // ================= ユーティリティ =================
    function $(sel, root=document){ return root.querySelector(sel); }
    function $all(sel, root=document){ return [...root.querySelectorAll(sel)]; }

    function csvEscape(val) {
      if (val == null) return "";
      const s = String(val);
      if (/[",\n\r]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }

    async function downloadCsv(filename, csvText) {
      const BOM = "\uFEFF";
      const blob = new Blob([BOM + csvText], { type: "text/csv;charset=utf-8" });
      const canShowPicker = (typeof window.showSaveFilePicker === 'function') && isSecureContext;
      if (canShowPicker) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: filename,
            types: [{ description: 'CSV File', accept: { 'text/csv': ['.csv'] } }]
          });
          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();
          return;
        } catch {}
      }
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    function teamKey(name) {
      return name.replace(/\s+/g, "_").replace(/[^\w\u00C0-\uFFFF\-]/g, "_");
    }

    function setError(el, on=true){ if(!el) return; el.classList.toggle('err', !!on); }

    function renderErrors(list){
      const box = document.getElementById("errorBox");
      if(!box) return;
      if(!list || list.length === 0){ box.style.display = 'none'; box.innerHTML = ''; return; }
      box.style.display = 'block';
      const items = list.map(s => `<li>${s}</li>`).join('');
      box.innerHTML = `<strong>未入力/未選択があります（${list.length}件）:</strong><ul>${items}</ul>`;
      const firstErr = document.querySelector('.err');
      if(firstErr){ firstErr.scrollIntoView({behavior:'smooth', block:'center'}); }
    }

    function updateSaveDialogStatus(){
      const el = document.getElementById('saveDialogStatus');
      if(!el) return;
      const canShowPicker = (typeof window.showSaveFilePicker === 'function') && isSecureContext;
      if (canShowPicker) {
        el.textContent = '保存時は毎回ダイアログが表示されます（対応ブラウザ・セキュア環境）。';
      } else {
        el.innerHTML = `現在のプレビュー環境では毎回の保存ダイアログを表示できません。<br>
          次のいずれかでご利用ください：
          <ol style="margin:6px 0 0 18px;">
            <li>ローカル開発サーバで開く（例：<code>http://localhost</code>）。</li>
            <li>GitHub Pages などの <code>https://</code> でホストする。</li>
            <li>Chrome 設定→ダウンロード→「ダウンロード前に各ファイルの保存場所を確認する」をON。</li>
          </ol>`;
      }
    }

    // ================== データ読み込み（match パラメータ） ==================
    async function loadLinesFile(path){
  const res = await fetch(path);
  if(!res.ok) throw new Error(`ファイル読込エラー: ${path}`);
  const text = await res.text();
  return [...new Set(text.split(/\r?\n/).map(s => s.trim()).filter(Boolean))];
}

function readLinesFromFile(file){
  return new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onerror = () => reject(new Error('ファイルの読み込みに失敗しました'));
    r.onload = () => {
      const text = String(r.result ?? '');
      const lines = [...new Set(text.split(/\r?\n/).map(s => s.trim()).filter(Boolean))];
      resolve(lines);
    };
    r.readAsText(file, 'utf-8');
  });
}

async function loadTeamFile(basename){
  return await loadLinesFile(`./data/${basename}.txt`);
}

async function loadCriteria(){
  // 仕様: ./setting/eval-points.txt を読み、1行=1観点テキスト
  // ファイルが読めない場合はエラー表示し、既定観点にフォールバック（授業停止を避ける）
  try{
    const lines = await loadLinesFile('./setting/eval-points.txt');
    if(lines.length === 0) throw new Error('観点設定ファイルが空です（setting/eval-points.txt）');
    CRITERIA = lines.map((t, i) => ({ id: `c${i+1}`, label: `観点${i+1}: ${t}` }));
  }catch(err){
    // フォールバック
    CRITERIA = DEFAULT_CRITERIA.map((t, i) => ({ id: `c${i+1}`, label: `観点${i+1}: ${t}` }));
    const status = document.getElementById('loadStatus');
    if(status) status.textContent = `観点設定の読み込みに失敗したため既定観点で続行します: ${err.message}`;
  }
  buildHeader();
  // ヒント行（CSVヘッダ表示）も更新
  const hint = document.querySelector('.hint');
  if(hint){
    hint.textContent = `CSV（ヘッダ付き）：${HEADER.join(', ')}`;
  }
}

    function getMatchKey(){
      const p = new URLSearchParams(location.search);
      const key = (p.get('match') || 'class-all').toLowerCase();
      return key;
    }

    let ALL_TEAMS = [];
    let TEAMS = [];

    async function initData(){
  const status = document.getElementById('loadStatus');
  try{
    const matchKey = getMatchKey();

    // 観点を先に読み込み（画面生成・CSVヘッダ生成に必要）
    await loadCriteria();

    // file:// の場合は fetch で data/ を読めないことが多いので、ファイル選択UIへ誘導
    if(location.protocol === 'file:'){
      status.innerHTML = `ローカル（file://）で開かれているため <span class="kbd">fetch('./data/...')</span> が使えない環境です。<br>
      下の「ローカル実行用：設定/データを選択」から <b>class-all.txt</b> と <b>${matchKey}.txt</b> を選択してください。`;
      showLocalPickers(matchKey);
      return;
    }

    status.textContent = `チームリスト読込: ${matchKey}.txt`;

    [ALL_TEAMS, TEAMS] = await Promise.all([
      loadTeamFile('class-all'),
      loadTeamFile(matchKey)
    ]);

    const sel = document.getElementById('myTeam');
    sel.innerHTML = '<option value="">選択してください</option>' +
      ALL_TEAMS.map(n => `<option value="${n}">${n}</option>`).join('');

    buildTeamSections(TEAMS);
    updateVisibility();
    status.textContent = `読み込み完了（対象 ${TEAMS.length} チーム / 全チーム ${ALL_TEAMS.length} / 観点 ${CRITERIA.length}）`;
  }catch(err){
    status.textContent = `読み込み失敗: ${err.message}`;
  }
}

// ================== ローカル実行（file://）用：ファイル選択UI ==================
function ensureLocalPickerUI(){
  if(document.getElementById('localPickerSection')) return;
  const anchor = document.getElementById('teamsContainer');
  const sec = document.createElement('div');
  sec.className = 'section';
  sec.id = 'localPickerSection';
  sec.style.display = 'none';
  sec.innerHTML = `
    <div class="team-title">ローカル実行用：設定/データを選択</div>
    <div class="muted">file:// で開く場合、ブラウザの制約で data/ や setting/ を fetch できないことがあります。その場合はここから読み込んでください。</div>
    <div style="margin-top:10px;" class="grid-2">
      <label>全チーム一覧（data/class-all.txt）<br><input type="file" id="pickAllTeams" accept=".txt,text/plain" /></label>
      <label>評価対象一覧（data/<span id="matchNameHere"></span>.txt）<br><input type="file" id="pickMatchTeams" accept=".txt,text/plain" /></label>
    </div>
    <div style="margin-top:10px;">
      <label>観点設定（setting/eval-points.txt）<span class="muted">（任意：未選択なら既定観点を使用）</span><br>
        <input type="file" id="pickCriteria" accept=".txt,text/plain" />
      </label>
    </div>
    <div style="margin-top:12px;">
      <button id="applyLocalFiles" type="button">このファイルで開始</button>
      <span id="localApplyStatus" class="muted" style="margin-left:10px;"></span>
    </div>
  `;
  anchor.parentNode.insertBefore(sec, anchor);
}

function showLocalPickers(matchKey){
  ensureLocalPickerUI();
  const sec = document.getElementById('localPickerSection');
  sec.style.display = '';
  document.getElementById('matchNameHere').textContent = matchKey;

  document.getElementById('applyLocalFiles').onclick = async () => {
    const st = document.getElementById('localApplyStatus');
    st.textContent = '読み込み中…';
    try{
      const fAll = document.getElementById('pickAllTeams').files?.[0];
      const fMatch = document.getElementById('pickMatchTeams').files?.[0];
      const fCrit = document.getElementById('pickCriteria').files?.[0];
      if(!fAll) throw new Error('class-all.txt を選択してください');
      if(!fMatch) throw new Error(`${matchKey}.txt を選択してください`);

      if(fCrit){
        const lines = await readLinesFromFile(fCrit);
        if(lines.length === 0) throw new Error('観点設定ファイルが空です（eval-points.txt）');
        CRITERIA = lines.map((t, i) => ({ id: `c${i+1}`, label: `観点${i+1}: ${t}` }));
        buildHeader();
        const hint = document.querySelector('.hint');
        if(hint) hint.textContent = `CSV（ヘッダ付き）：${HEADER.join(', ')}`;
      }

      ALL_TEAMS = await readLinesFromFile(fAll);
      TEAMS = await readLinesFromFile(fMatch);

      const sel = document.getElementById('myTeam');
      sel.innerHTML = '<option value="">選択してください</option>' +
        ALL_TEAMS.map(n => `<option value="${n}">${n}</option>`).join('');

      buildTeamSections(TEAMS);
      updateVisibility();

      document.getElementById('loadStatus').textContent = `読み込み完了（ローカル）：対象 ${TEAMS.length} チーム / 全チーム ${ALL_TEAMS.length} / 観点 ${CRITERIA.length}`;
      st.textContent = 'OK';
    }catch(err){
      st.textContent = `失敗: ${err.message}`;
    }
  };
}

// ================== 画面生成 ==================
    function buildTeamSections(teams){
  const container = document.getElementById('teamsContainer');
  container.innerHTML = '';
  teams.forEach(teamName => {
    const tKey = teamKey(teamName);
    const section = document.createElement('div');
    section.className = 'section';
    section.dataset.team = teamName;

    const header = document.createElement('div');
    header.className = 'team-title';
    header.textContent = `評価対象チーム：${teamName}`;
    section.appendChild(header);

    const criteriaDiv = document.createElement('div');
    criteriaDiv.className = 'criteria';

    CRITERIA.forEach(crit => {
      const critWrap = document.createElement('div');
      critWrap.className = 'criterion';

      const label = document.createElement('div');
      label.textContent = crit.label;
      critWrap.appendChild(label);

      const choices = document.createElement('div');
      choices.className = 'choices';

      const groupName = `${tKey}_${crit.id}`;
      SCALE.forEach(sc => {
        const id = `${groupName}_${sc.value}`;
        const input = document.createElement('input');
        input.type = 'radio'; input.id = id; input.name = groupName; input.value = sc.value;
        const lab = document.createElement('label'); lab.className = 'choice'; lab.setAttribute('for', id);
        lab.appendChild(input);
        const span = document.createElement('span'); span.textContent = sc.text; lab.appendChild(span);
        choices.appendChild(lab);
      });

      critWrap.appendChild(choices);
      criteriaDiv.appendChild(critWrap);
    });

    const comments = document.createElement('div');
    comments.className = 'grid-2';
    comments.innerHTML = `
      <label>良かった点（コメント）<textarea id="${tKey}_good"></textarea></label>
      <label>改善できる点（コメント）<textarea id="${tKey}_improve"></textarea></label>`;

    section.appendChild(criteriaDiv);
    section.appendChild(comments);
    container.appendChild(section);
  });
}

function teamsToEvaluate(myTeam){
      return TEAMS.filter(t => t !== myTeam);
    }

    function updateVisibility(){
      const myTeam = document.getElementById('myTeam').value;
      $all('[data-team]').forEach(sec => {
        sec.style.display = (myTeam && sec.dataset.team === myTeam) ? 'none' : '';
      });
    }

    document.getElementById('myTeam').addEventListener('change', updateVisibility);

    function validateAll(){
      let ok = true; const errors = [];
      setError(document.getElementById('myName'), false);
      setError(document.getElementById('myTeam'), false);
      $all('.criterion, textarea').forEach(el => setError(el, false));

      const myName = (document.getElementById('myName').value || '').trim();
      const myTeam = document.getElementById('myTeam').value;
      if(!myName){ ok = false; errors.push('自分の名前'); setError(document.getElementById('myName'), true); }
      if(!myTeam){ ok = false; errors.push('自分のチーム'); setError(document.getElementById('myTeam'), true); }
      // 自チームの存在チェック（class-all に含まれていること）
      if(myTeam && !ALL_TEAMS.includes(myTeam)){
        ok = false; errors.push('自分のチームが class-all に存在しません'); setError(document.getElementById('myTeam'), true);
      }

      const targets = teamsToEvaluate(myTeam);
      targets.forEach(teamName => {
        const tKey = teamKey(teamName);
        CRITERIA.forEach(crit => {
          const groupName = `${tKey}_${crit.id}`;
          const groupEls = $all(`input[type=\"radio\"][name=\"${groupName}\"]`);
          const anyChecked = groupEls.some(el => el.checked);
          if(!anyChecked){ ok = false; errors.push(`${teamName} の ${crit.label}`); const parent = groupEls[0]?.closest('.criterion'); setError(parent, true); }
        });
        const good = document.getElementById(`${tKey}_good`);
        const improve = document.getElementById(`${tKey}_improve`);
        if(!good.value.trim()){ ok = false; errors.push(`${teamName} の 良かった点`); setError(good, true); }
        if(!improve.value.trim()){ ok = false; errors.push(`${teamName} の 改善できる点`); setError(improve, true); }
      });

      return { ok, errors, myName, myTeam, targets };
    }

    // ================= CSV 生成 =================
    document.getElementById('saveBtn').addEventListener('click', async () => {
      const { ok, errors, myName, myTeam, targets } = validateAll();
      renderErrors(errors);
      if(!ok) return;

      const lines = [];
      lines.push(HEADER.map(csvEscape).join(','));
      targets.forEach(teamName => {
        const tKey = teamKey(teamName);
        const scores = CRITERIA.map(crit => {
          const groupName = `${tKey}_${crit.id}`;
          const checked = document.querySelector(`input[type=\"radio\"][name=\"${groupName}\"]:checked`);
          return checked ? checked.value : '';
        });
        const good = (document.getElementById(`${tKey}_good`)?.value || '').trim();
        const improve = (document.getElementById(`${tKey}_improve`)?.value || '').trim();
        const ts = formatTimestamp();
        const row = [ts, myName, teamName, ...scores, good, improve].map(csvEscape).join(',');
        lines.push(row);
      });

      const csv = lines.join(EOL);
      const filename = `相互評価(${myName}).csv`;
      await downloadCsv(filename, csv);
      renderErrors([]);
    });

    // ========== 初期化 ==========
    updateSaveDialogStatus();
    // タイトルに (match) を追加
    (function(){
      const p = new URLSearchParams(location.search);
      const key = (p.get('match') || 'class-all').toLowerCase();
      const titleEl = document.getElementById('pageTitle');
      if(titleEl) titleEl.textContent = `相互評価フォーム(${key}) [build ${BUILD_ID}]`;
      // ブラウザのタブタイトルにも反映
      document.title = `相互評価フォーム(${key}) [build ${BUILD_ID}]`;
    })();

    initData().then(() => {
      const { errors } = validateAll();
      renderErrors(errors);
    });

    // ▼ リアルタイム検証（動的生成後でも確実に拾うため委任で常時有効）
    document.addEventListener('input', (e) => {
      if (e.target.matches('#myName, textarea, input[type="text"]')) {
        const { errors } = validateAll();
        renderErrors(errors);
      }
    });
    document.addEventListener('change', (e) => {
      if (e.target.matches('#myTeam')) {
        updateVisibility();
        const { errors } = validateAll();
        renderErrors(errors);
      }
      if (e.target.matches('input[type="radio"], textarea, input[type="text"]')) {
        const { errors } = validateAll();
        renderErrors(errors);
      }
    });

    // ========== 簡易テスト（既存は保持しつつ、動的読み込みに合わせて拡張） ==========
    (function runSmokeTests(){
      // 改行テスト
      const sample = ['a,b', 'c,d']; 
      const lf = sample.join('\n');
      const crlf = sample.join('\r\n');
      console.assert(lf === 'a,b\nc,d', 'LF join failed');
      console.assert(crlf === 'a,b\r\nc,d', 'CRLF join failed');
      // CSVエスケープ
      console.assert(csvEscape('a"b') === '"a""b"', 'csvEscape quote fail');
      console.assert(csvEscape('a,b') === '"a,b"', 'csvEscape comma fail');
      console.assert(csvEscape('a\nb') === '"a\nb"', 'csvEscape newline fail');
      // teamsToEvaluate: ロジック検証（グローバル TEAMS を汚染しないローカル検証）
      (function(){
        const _tmpTeams = ['T1','T2','T3'];
        const expected = JSON.stringify(['T1','T3']);
        const actual = JSON.stringify(_tmpTeams.filter(t => t !== 'T2'));
        console.assert(actual === expected, 'teamsToEvaluate logic failed (local)');
      })();
    })();
  </script>
</body>
</html>
